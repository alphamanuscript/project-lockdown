import { randomBytes } from 'crypto';
import * as argon2 from 'argon2';
import { OAuth2Client } from 'google-auth-library';
import { createLoginError } from '../error';
import { ERROR_GOOGLE_LOGIN_FAILED } from '../messages';
import { validateEmail } from './validation-util';

export * from './validation-util';

export function hashPassword(plain: string): Promise<string> {
  return argon2.hash(plain);
}

export async function verifyPassword(hashed: string, plain: string): Promise<boolean> {
  try {
    return argon2.verify(hashed, plain);
  }
  catch (e)
  {
    return false;
  }
}

export function generateId(): string {
  return randomBytes(16).toString('hex');
}

export function generateToken(): string {
  return randomBytes(64).toString('hex');
}

export function generateCode(): string {
  return Math.floor(1000 + Math.random() * 9000).toString();
}


export function hasOnlyAllowedKeys (arg: any, allowedKeys: string[]): boolean {
  return arg ? !Object.keys(arg).some(key => !allowedKeys.includes(key)) : false;
}

interface GoogleUserData {
  email: string,
  name: string
}

/**
 * verifies the integrity of the Google ID token
 * @param token the ID token generated by Google during sign-in
 * @returns the Google account's email address
 */
export async function verifyGoogleIdToken(token: string): Promise<GoogleUserData> {
  try {
    const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID
    });
    const payload = ticket.getPayload();
    const email = payload.email;
    const name = payload.name;
    validateEmail(email);
    return { email, name };
  }
  catch (e) {
    throw createLoginError(ERROR_GOOGLE_LOGIN_FAILED)
  }
}